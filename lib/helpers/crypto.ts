import * as crypto from 'crypto';
import env from '../constants/env';

const KEY_LENGTH = 32; // 256-bit
const IV_LENGTH = 12; // 96-bit nonce for GCM
const TAG_LENGTH = 16; // 128-bit auth tag

/**
 * Encryption algorithm used for internal data (AES-256-GCM).
 */
const ALGORITHM = 'aes-256-gcm';

/**
 * Key derived from JWT_ACCESS_SECRET and SALT using scrypt.
 */
const ENCRYPTION_KEY = crypto.scryptSync(env.JWT_ACCESS_SECRET as string, env.SALT as string, KEY_LENGTH);

/**
 * Encrypts a string using AES-256-GCM.
 * The output includes the IV and Auth Tag for secure decryption.
 * 
 * @param {string} text - The plain text to encrypt.
 * @returns {string} Base64 encoded string containing IV + Auth Tag + Ciphertext.
 * 
 * @example
 * const encrypted = encrypt("my secret data");
 */
export function encrypt(text: string): string {
  const iv = crypto.randomBytes(IV_LENGTH);
  const cipher = crypto.createCipheriv(ALGORITHM, ENCRYPTION_KEY, iv);

  const encrypted = Buffer.concat([cipher.update(text, 'utf8'), cipher.final()]);
  const authTag = cipher.getAuthTag();

  // Return IV + authTag + ciphertext as base64
  return Buffer.concat([iv, authTag, encrypted]).toString('base64');
}

/**
 * Decrypts a Base64 string encrypted with the `encrypt` function.
 * 
 * @param {string} text - The Base64 encoded encrypted string.
 * @returns {string} The original decrypted plain text.
 * @throws {Error} If decryption fails (e.g., invalid key or tampered data).
 */
export function decrypt(text: string): string {
  const data = Buffer.from(text, 'base64');
  const iv = Buffer.from(data.buffer, data.byteOffset, IV_LENGTH);
  const authTag = Buffer.from(data.buffer, data.byteOffset + IV_LENGTH, TAG_LENGTH);
  const ciphertext = data.subarray(IV_LENGTH + TAG_LENGTH);

  const decipher = crypto.createDecipheriv(ALGORITHM, ENCRYPTION_KEY, iv);
  decipher.setAuthTag(authTag);

  const decrypted = Buffer.concat([decipher.update(ciphertext), decipher.final()]);
  return decrypted.toString('utf8');
}

/**
 * Generates a short-lived (5 min) authorization token for joining a chatroom.
 * Used as a proof-of-access after link validation.
 * 
 * @param {string} roomId - The ID of the chatroom.
 * @param {string} userAid - The AID of the user joining.
 * @returns {string} Encrypted join authorization token.
 */
export function generateJoinAuthToken(roomId: string, userAid: string): string {
  const payload = JSON.stringify({
    roomId,
    userAid,
    expiresAt: Date.now() + 5 * 60 * 1000, // 5 minutes expiry
    type: 'join_auth'
  });
  return encrypt(payload);
}

/**
 * Validates a join authorization token generated by `generateJoinAuthToken`.
 * 
 * @param {string} token - The encrypted token to validate.
 * @param {string} roomId - The expected chatroom ID.
 * @param {string} userAid - The expected user AID.
 * @returns {boolean} True if the token is valid and not expired.
 */
export function validateJoinAuthToken(token: string, roomId: string, userAid: string): boolean {
  try {
    const decrypted = decrypt(token);
    const payload = JSON.parse(decrypted);
    return (
      payload.type === 'join_auth' &&
      payload.roomId === roomId &&
      payload.userAid === userAid &&
      payload.expiresAt > Date.now()
    );
  } catch (err) {
    return false;
  }
}

/**
 * Generates a long-lived (24h) room access token (invite link token).
 * 
 * @param {string} roomId - The ID of the chatroom.
 * @param {string} [password] - Optional hashed password for the room.
 * @returns {Object} Object containing the token and its expiration timestamp.
 */
export function generateRoomAccessToken(roomId: string, password?: string): { token: string; expiresAt: number } {
  const expiresAt = Date.now() + 24 * 60 * 60 * 1000; // 24 hours expiry
  const payload = JSON.stringify({
    roomId,
    password: password || null,
    expiresAt,
  });
  return {
    token: encrypt(payload),
    expiresAt,
  };
}

/**
 * Validates and decrypts a room access token from an invite link.
 * 
 * @param {string} token - The encrypted access token.
 * @returns {Object} Decrypted payload with roomId and password.
 * @throws {Error} If the token is invalid or expired.
 */
export function validateRoomAccessToken(token: string): { roomId: string; password?: string } {
  try {
    const decrypted = decrypt(token);
    const payload = JSON.parse(decrypted);

    if (payload.expiresAt < Date.now()) {
      throw new Error('Token expired');
    }

    return {
      roomId: payload.roomId,
      password: payload.password || undefined,
    };
  } catch (err) {
    throw new Error('Invalid or expired token');
  }
}

/**
 * Verifies an Ed25519 digital signature for a message.
 * 
 * @param {string | Buffer} message - The original message that was signed.
 * @param {string} signature - The Base64 encoded signature.
 * @param {string} publicKey - The Base64 encoded Ed25519 public key.
 * @returns {boolean} True if the signature is valid for the given message and key.
 */
export function verifySignature(message: string | Buffer, signature: string, publicKey: string): boolean {
  try {
    const sigBuffer = Buffer.from(signature, 'base64');
    const keyBuffer = Buffer.from(publicKey, 'base64');

    return crypto.verify(
      null,
      Buffer.from(message),
      {
        key: keyBuffer,
        format: 'der',
        type: 'spki',
      },
      sigBuffer
    );
  } catch (err) {
    return false;
  }
}
